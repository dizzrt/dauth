// Code generated by protoc-gen-ellie-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-ellie-go-http v1.1.4
// - protoc             (unknown)
// source: identity/role.proto

package identity

import (
	context "context"
	log "github.com/dizzrt/ellie/log"
	http "github.com/dizzrt/ellie/transport/http"
	ginx "github.com/dizzrt/ellie/transport/http/ginx"
	gin "github.com/gin-gonic/gin"
	otel "go.opentelemetry.io/otel"
	attribute "go.opentelemetry.io/otel/attribute"
	propagation "go.opentelemetry.io/otel/propagation"
	v1_21_0 "go.opentelemetry.io/otel/semconv/v1.21.0"
	trace "go.opentelemetry.io/otel/trace"
)

var _ = new(context.Context)
var _ = new(gin.Engine)
var _ = new(ginx.Ginx)
var _ = new(http.Server)
var _ = otel.Tracer
var _ = new(trace.Span)
var _ = new(log.Logger)
var _ = new(attribute.KeyValue)
var _ = new(propagation.TextMapPropagator)
var _ = v1_21_0.HTTPRequestMethodKey

const TRACER_NAME_ROLE = "github.com/dizzrt/dauth/api/gen/identity"
const OperationRoleServiceAssignRoles = "/RoleService/AssignRoles"
const OperationRoleServiceCreateRole = "/RoleService/CreateRole"
const OperationRoleServiceDeleteRoles = "/RoleService/DeleteRoles"
const OperationRoleServiceGetRoles = "/RoleService/GetRoles"
const OperationRoleServiceUnassignRoles = "/RoleService/UnassignRoles"
const OperationRoleServiceUpdateRole = "/RoleService/UpdateRole"

type RoleServiceHTTPServer interface {
	// AssignRoles
	// AssignRoles assigns roles to a user.
	// @Param AssignRolesRequest
	// @Return AssignRolesResponse
	AssignRoles(context.Context, *AssignRolesRequest) (*AssignRolesResponse, error)
	// CreateRole
	// CreateRole creates a new role.
	// @Param CreateRoleRequest
	// @Return CreateRoleResponse
	CreateRole(context.Context, *CreateRoleRequest) (*CreateRoleResponse, error)
	// DeleteRoles
	// DeleteRoles deletes roles by IDs.
	// @Param DeleteRolesRequest
	// @Return DeleteRolesResponse
	DeleteRoles(context.Context, *DeleteRolesRequest) (*DeleteRolesResponse, error)
	// GetRoles
	// GetRoles gets all roles.
	// @Param GetRolesRequest
	// @Return GetRolesResponse
	GetRoles(context.Context, *GetRolesRequest) (*GetRolesResponse, error)
	// UnassignRoles
	// UnassignRoles unassigns roles from a user.
	// @Param UnassignRolesRequest
	// @Return UnassignRolesResponse
	UnassignRoles(context.Context, *UnassignRolesRequest) (*UnassignRolesResponse, error)
	// UpdateRole
	// UpdateRole updates a role by ID.
	// @Param UpdateRoleRequest
	// @Return UpdateRoleResponse
	UpdateRole(context.Context, *UpdateRoleRequest) (*UpdateRoleResponse, error)
}

func RegisterRoleServiceHTTPServer(hs *http.Server, srv RoleServiceHTTPServer) {
	r := hs.Engine()
	r.POST("/identity/role", _role_RoleService_POST_CreateRole_HTTP_Handler(hs, srv))
	r.GET("/identity/roles", _role_RoleService_GET_GetRoles_HTTP_Handler(hs, srv))
	r.POST("/identity/roles/delete", _role_RoleService_POST_DeleteRoles_HTTP_Handler(hs, srv))
	r.PUT("/identity/role/:id", _role_RoleService_PUT_UpdateRole_HTTP_Handler(hs, srv))
	r.PUT("/identity/role/:id/roles", _role_RoleService_PUT_AssignRoles_HTTP_Handler(hs, srv))
	r.POST("/identity/role/:id/roles", _role_RoleService_POST_UnassignRoles_HTTP_Handler(hs, srv))
}
func _role_RoleService_POST_CreateRole_HTTP_Handler(hs *http.Server, srv RoleServiceHTTPServer) gin.HandlerFunc {
	return func(ctx *gin.Context) {
		var req CreateRoleRequest
		if err := ginx.DecodeRequest(ctx, &req); err != nil {
			ctx.JSON(http.StatusBadRequest, hs.WrapHTTPResponse(nil, err))
			ctx.Abort()
			return
		}

		greq := ctx.Request
		rctx := greq.Context()
		rctx = log.ExtractFromTextMapCarrier(rctx, propagation.HeaderCarrier(greq.Header))
		attributes := []attribute.KeyValue{
			v1_21_0.HTTPRequestMethodKey.String(greq.Method),
			v1_21_0.HTTPRouteKey.String(greq.URL.String()),
			attribute.String("log.id", log.LogIDFromContext(rctx)),
		}

		tracer := otel.Tracer(TRACER_NAME_ROLE)
		rctx, span := tracer.Start(rctx, "_RoleService_CreateRole_0_HTTP_Handler",
			trace.WithSpanKind(trace.SpanKindServer),
			trace.WithAttributes(attributes...),
		)
		defer span.End()

		sctx := span.SpanContext()
		rctx = log.WithTraceID(rctx, sctx.TraceID().String())
		rctx = log.WithSpanID(rctx, sctx.SpanID().String())

		res, err := srv.CreateRole(rctx, &req)
		ctx.Request = ctx.Request.WithContext(rctx)
		if err != nil {
			ctx.JSON(http.HTTPStatusCodeFromError(err), hs.WrapHTTPResponse(res, err))
			ctx.Abort()
			return
		}

		hs.EncodeResponse(ctx, res, err)
	}
}
func _role_RoleService_GET_GetRoles_HTTP_Handler(hs *http.Server, srv RoleServiceHTTPServer) gin.HandlerFunc {
	return func(ctx *gin.Context) {
		var req GetRolesRequest
		if err := ginx.DecodeRequest(ctx, &req); err != nil {
			ctx.JSON(http.StatusBadRequest, hs.WrapHTTPResponse(nil, err))
			ctx.Abort()
			return
		}

		greq := ctx.Request
		rctx := greq.Context()
		rctx = log.ExtractFromTextMapCarrier(rctx, propagation.HeaderCarrier(greq.Header))
		attributes := []attribute.KeyValue{
			v1_21_0.HTTPRequestMethodKey.String(greq.Method),
			v1_21_0.HTTPRouteKey.String(greq.URL.String()),
			attribute.String("log.id", log.LogIDFromContext(rctx)),
		}

		tracer := otel.Tracer(TRACER_NAME_ROLE)
		rctx, span := tracer.Start(rctx, "_RoleService_GetRoles_0_HTTP_Handler",
			trace.WithSpanKind(trace.SpanKindServer),
			trace.WithAttributes(attributes...),
		)
		defer span.End()

		sctx := span.SpanContext()
		rctx = log.WithTraceID(rctx, sctx.TraceID().String())
		rctx = log.WithSpanID(rctx, sctx.SpanID().String())

		res, err := srv.GetRoles(rctx, &req)
		ctx.Request = ctx.Request.WithContext(rctx)
		if err != nil {
			ctx.JSON(http.HTTPStatusCodeFromError(err), hs.WrapHTTPResponse(res, err))
			ctx.Abort()
			return
		}

		hs.EncodeResponse(ctx, res, err)
	}
}
func _role_RoleService_POST_DeleteRoles_HTTP_Handler(hs *http.Server, srv RoleServiceHTTPServer) gin.HandlerFunc {
	return func(ctx *gin.Context) {
		var req DeleteRolesRequest
		if err := ginx.DecodeRequest(ctx, &req); err != nil {
			ctx.JSON(http.StatusBadRequest, hs.WrapHTTPResponse(nil, err))
			ctx.Abort()
			return
		}

		greq := ctx.Request
		rctx := greq.Context()
		rctx = log.ExtractFromTextMapCarrier(rctx, propagation.HeaderCarrier(greq.Header))
		attributes := []attribute.KeyValue{
			v1_21_0.HTTPRequestMethodKey.String(greq.Method),
			v1_21_0.HTTPRouteKey.String(greq.URL.String()),
			attribute.String("log.id", log.LogIDFromContext(rctx)),
		}

		tracer := otel.Tracer(TRACER_NAME_ROLE)
		rctx, span := tracer.Start(rctx, "_RoleService_DeleteRoles_0_HTTP_Handler",
			trace.WithSpanKind(trace.SpanKindServer),
			trace.WithAttributes(attributes...),
		)
		defer span.End()

		sctx := span.SpanContext()
		rctx = log.WithTraceID(rctx, sctx.TraceID().String())
		rctx = log.WithSpanID(rctx, sctx.SpanID().String())

		res, err := srv.DeleteRoles(rctx, &req)
		ctx.Request = ctx.Request.WithContext(rctx)
		if err != nil {
			ctx.JSON(http.HTTPStatusCodeFromError(err), hs.WrapHTTPResponse(res, err))
			ctx.Abort()
			return
		}

		hs.EncodeResponse(ctx, res, err)
	}
}
func _role_RoleService_PUT_UpdateRole_HTTP_Handler(hs *http.Server, srv RoleServiceHTTPServer) gin.HandlerFunc {
	return func(ctx *gin.Context) {
		var req UpdateRoleRequest
		if err := ginx.DecodeRequest(ctx, &req); err != nil {
			ctx.JSON(http.StatusBadRequest, hs.WrapHTTPResponse(nil, err))
			ctx.Abort()
			return
		}

		greq := ctx.Request
		rctx := greq.Context()
		rctx = log.ExtractFromTextMapCarrier(rctx, propagation.HeaderCarrier(greq.Header))
		attributes := []attribute.KeyValue{
			v1_21_0.HTTPRequestMethodKey.String(greq.Method),
			v1_21_0.HTTPRouteKey.String(greq.URL.String()),
			attribute.String("log.id", log.LogIDFromContext(rctx)),
		}

		tracer := otel.Tracer(TRACER_NAME_ROLE)
		rctx, span := tracer.Start(rctx, "_RoleService_UpdateRole_0_HTTP_Handler",
			trace.WithSpanKind(trace.SpanKindServer),
			trace.WithAttributes(attributes...),
		)
		defer span.End()

		sctx := span.SpanContext()
		rctx = log.WithTraceID(rctx, sctx.TraceID().String())
		rctx = log.WithSpanID(rctx, sctx.SpanID().String())

		res, err := srv.UpdateRole(rctx, &req)
		ctx.Request = ctx.Request.WithContext(rctx)
		if err != nil {
			ctx.JSON(http.HTTPStatusCodeFromError(err), hs.WrapHTTPResponse(res, err))
			ctx.Abort()
			return
		}

		hs.EncodeResponse(ctx, res, err)
	}
}
func _role_RoleService_PUT_AssignRoles_HTTP_Handler(hs *http.Server, srv RoleServiceHTTPServer) gin.HandlerFunc {
	return func(ctx *gin.Context) {
		var req AssignRolesRequest
		if err := ginx.DecodeRequest(ctx, &req); err != nil {
			ctx.JSON(http.StatusBadRequest, hs.WrapHTTPResponse(nil, err))
			ctx.Abort()
			return
		}

		greq := ctx.Request
		rctx := greq.Context()
		rctx = log.ExtractFromTextMapCarrier(rctx, propagation.HeaderCarrier(greq.Header))
		attributes := []attribute.KeyValue{
			v1_21_0.HTTPRequestMethodKey.String(greq.Method),
			v1_21_0.HTTPRouteKey.String(greq.URL.String()),
			attribute.String("log.id", log.LogIDFromContext(rctx)),
		}

		tracer := otel.Tracer(TRACER_NAME_ROLE)
		rctx, span := tracer.Start(rctx, "_RoleService_AssignRoles_0_HTTP_Handler",
			trace.WithSpanKind(trace.SpanKindServer),
			trace.WithAttributes(attributes...),
		)
		defer span.End()

		sctx := span.SpanContext()
		rctx = log.WithTraceID(rctx, sctx.TraceID().String())
		rctx = log.WithSpanID(rctx, sctx.SpanID().String())

		res, err := srv.AssignRoles(rctx, &req)
		ctx.Request = ctx.Request.WithContext(rctx)
		if err != nil {
			ctx.JSON(http.HTTPStatusCodeFromError(err), hs.WrapHTTPResponse(res, err))
			ctx.Abort()
			return
		}

		hs.EncodeResponse(ctx, res, err)
	}
}
func _role_RoleService_POST_UnassignRoles_HTTP_Handler(hs *http.Server, srv RoleServiceHTTPServer) gin.HandlerFunc {
	return func(ctx *gin.Context) {
		var req UnassignRolesRequest
		if err := ginx.DecodeRequest(ctx, &req); err != nil {
			ctx.JSON(http.StatusBadRequest, hs.WrapHTTPResponse(nil, err))
			ctx.Abort()
			return
		}

		greq := ctx.Request
		rctx := greq.Context()
		rctx = log.ExtractFromTextMapCarrier(rctx, propagation.HeaderCarrier(greq.Header))
		attributes := []attribute.KeyValue{
			v1_21_0.HTTPRequestMethodKey.String(greq.Method),
			v1_21_0.HTTPRouteKey.String(greq.URL.String()),
			attribute.String("log.id", log.LogIDFromContext(rctx)),
		}

		tracer := otel.Tracer(TRACER_NAME_ROLE)
		rctx, span := tracer.Start(rctx, "_RoleService_UnassignRoles_0_HTTP_Handler",
			trace.WithSpanKind(trace.SpanKindServer),
			trace.WithAttributes(attributes...),
		)
		defer span.End()

		sctx := span.SpanContext()
		rctx = log.WithTraceID(rctx, sctx.TraceID().String())
		rctx = log.WithSpanID(rctx, sctx.SpanID().String())

		res, err := srv.UnassignRoles(rctx, &req)
		ctx.Request = ctx.Request.WithContext(rctx)
		if err != nil {
			ctx.JSON(http.HTTPStatusCodeFromError(err), hs.WrapHTTPResponse(res, err))
			ctx.Abort()
			return
		}

		hs.EncodeResponse(ctx, res, err)
	}
}
